---
import Layout from '../layouts/Layout.astro';
import Touchmark from '../components/Touchmark.astro';
import SocialLinks from '../components/SocialLinks.astro';
---

<Layout title="Joel Huggett" description="About Joel Huggett.">
  <main>
    <div class="hero" id="hero">
      <canvas id="ember-canvas"></canvas>
      <div class="hero-spacer"></div>

      <div class="hero-identity" id="hero-identity">
        <div class="touchmark-glow" id="touchmark-glow">
          <Touchmark class="touchmark-svg" transition:name="touchmark" />
        </div>
        <h1 class="hero-stagger" style="--stagger: 1">Joel Huggett</h1>
        <p class="hero-tagline hero-stagger" style="--stagger: 2">Blacksmith &bull; Software Engineer &bull; Woodwright</p>
        <nav class="hero-nav hero-stagger" style="--stagger: 3">
          <a href="/blog">Blog</a>
          <a href="/games">Games</a>
          <a href="/apps">Apps</a>
        </nav>
      </div>

      <footer class="hero-footer hero-stagger" style="--stagger: 4">
        <SocialLinks />
      </footer>
    </div>
  </main>
</Layout>

<style is:global>
  .touchmark-svg {
    width: 10rem;
  }

  /* Ember canvas */
  #ember-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
  }

  /* Content above canvas */
  .hero-identity,
  .hero-spacer,
  .hero-footer {
    position: relative;
    z-index: 2;
  }

  /* Touchmark glow wrapper */
  .touchmark-glow {
    animation: hero-rise 0.8s ease-out both;
  }

  /* Staggered entrance */
  .hero-stagger {
    animation: hero-rise 0.6s ease-out both;
    animation-delay: calc(var(--stagger) * 0.12s + 0.4s);
  }

  @keyframes hero-rise {
    from {
      opacity: 0;
      transform: translateY(1.5rem);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Tilt target (touchmark only) */
  .touchmark-glow {
    will-change: transform, filter;
  }

  /* Accessibility */
  @media (prefers-reduced-motion: reduce) {
    .touchmark-glow,
    .hero-stagger {
      animation: none;
    }
    #ember-canvas {
      display: none;
    }
    .touchmark-glow {
      will-change: auto;
    }
  }
</style>

<script>
  function init() {
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

    const hero = document.getElementById('hero');
    const identity = document.getElementById('hero-identity');
    const touchmarkEl = document.getElementById('touchmark-glow');
    const canvas = document.getElementById('ember-canvas') as HTMLCanvasElement | null;
    const ctx = canvas?.getContext('2d');
    if (!hero || !identity || !touchmarkEl || !canvas || !ctx) return;

    // --- Canvas sizing ---
    function resize() {
      canvas!.width = hero!.offsetWidth;
      canvas!.height = hero!.offsetHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // --- Mouse state ---
    let mouseX = 0;
    let mouseY = 0;
    let mouseInHero = false;

    hero.addEventListener('mousemove', (e: MouseEvent) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      mouseInHero = true;
    });

    hero.addEventListener('mouseleave', () => {
      mouseInHero = false;
    });

    // --- Spark particles ---
    interface Spark {
      x: number; y: number;
      px: number; py: number;
      vx: number; vy: number;
      life: number; decay: number;
      size: number;
      brightness: number;
    }

    const sparks: Spark[] = [];
    const MAX_SPARKS = 50;

    function getOrigin() {
      const heroRect = hero!.getBoundingClientRect();
      const tmRect = touchmarkEl!.getBoundingClientRect();
      return {
        x: tmRect.left - heroRect.left + tmRect.width / 2,
        y: tmRect.top - heroRect.top + tmRect.height * 0.7,
        w: tmRect.width,
      };
    }

    function spawnSpark() {
      if (sparks.length >= MAX_SPARKS) return;
      const o = getOrigin();
      const spawnX = o.x + (Math.random() - 0.5) * o.w * 0.5;
      const spawnY = o.y + (Math.random() - 0.5) * 10;

      // Mostly upward with spread, some go wide
      const angle = -Math.PI / 2 + (Math.random() - 0.5) * 1.8;
      const speed = Math.random() * 2.5 + 0.8;

      sparks.push({
        x: spawnX, y: spawnY,
        px: spawnX, py: spawnY,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 1.0,
        decay: Math.random() * 0.015 + 0.006,
        size: Math.random() * 1.8 + 0.4,
        brightness: Math.random(),
      });
    }

    // --- Smoothed values ---
    let glow = 0;
    let tiltX = 0;
    let tiltY = 0;

    function lerp(a: number, b: number, t: number) {
      return a + (b - a) * t;
    }

    // --- Animation loop ---
    let frame = 0;

    function tick() {
      if (!hero!.isConnected) {
        window.removeEventListener('resize', resize);
        return;
      }
      requestAnimationFrame(tick);
      frame++;

      const o = getOrigin();

      // --- Mouse proximity ---
      const tmRect = touchmarkEl!.getBoundingClientRect();
      const tmCX = tmRect.left + tmRect.width / 2;
      const tmCY = tmRect.top + tmRect.height / 2;

      let proximity = 0;
      if (mouseInHero) {
        const dx = mouseX - tmCX;
        const dy = mouseY - tmCY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        proximity = Math.max(0, 1 - dist / 500);
      }
      glow = lerp(glow, mouseInHero ? proximity : 0, mouseInHero ? 0.06 : 0.03);

      // --- Clear canvas ---
      ctx!.clearRect(0, 0, canvas!.width, canvas!.height);

      // --- Draw forge glow (canvas radial gradient) ---
      const ambientGlow = 0.04;
      const glowStrength = ambientGlow + glow * 0.35;
      const glowRadius = 140 + glow * 120;

      // Offset glow slightly toward mouse for "light source" feel
      let glowOffX = 0;
      let glowOffY = 0;
      if (mouseInHero && glow > 0.01) {
        const heroRect = hero!.getBoundingClientRect();
        const mxLocal = mouseX - heroRect.left;
        const myLocal = mouseY - heroRect.top;
        const dx = mxLocal - o.x;
        const dy = myLocal - o.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 0) {
          glowOffX = (dx / dist) * glow * 20;
          glowOffY = (dy / dist) * glow * 20;
        }
      }

      const gx = o.x + glowOffX;
      const gy = o.y + glowOffY;
      const grad = ctx!.createRadialGradient(gx, gy, 0, gx, gy, glowRadius);
      grad.addColorStop(0, `rgba(200, 90, 20, ${glowStrength})`);
      grad.addColorStop(0.3, `rgba(160, 60, 10, ${glowStrength * 0.6})`);
      grad.addColorStop(0.7, `rgba(120, 40, 5, ${glowStrength * 0.2})`);
      grad.addColorStop(1, 'rgba(100, 30, 0, 0)');
      ctx!.fillStyle = grad;
      ctx!.beginPath();
      ctx!.arc(gx, gy, glowRadius, 0, Math.PI * 2);
      ctx!.fill();

      // --- Spawn sparks ---
      const spawnInterval = Math.max(4, 12 - Math.floor(glow * 10));
      if (frame % spawnInterval === 0) spawnSpark();

      // --- Update & draw sparks ---
      ctx!.lineCap = 'round';

      for (let i = sparks.length - 1; i >= 0; i--) {
        const s = sparks[i];

        // Store previous position
        s.px = s.x;
        s.py = s.y;

        // Physics
        s.x += s.vx;
        s.y += s.vy;
        s.vy += 0.015;  // gravity pulls down
        s.vx *= 0.997;  // slight air drag
        s.vy *= 0.997;
        s.vx += (Math.random() - 0.5) * 0.03; // turbulence
        s.life -= s.decay;

        if (s.life <= 0) {
          sparks.splice(i, 1);
          continue;
        }

        // Flicker
        const flicker = 0.75 + Math.random() * 0.25;
        const alpha = Math.pow(s.life, 0.7) * flicker;

        // Calculate trail length (min length so it's always a streak, not a dot)
        let dx = s.x - s.px;
        let dy = s.y - s.py;
        const trailLen = Math.sqrt(dx * dx + dy * dy);
        // Extend short trails so sparks always look like streaks
        if (trailLen < 3) {
          const speed = Math.sqrt(s.vx * s.vx + s.vy * s.vy);
          if (speed > 0.01) {
            dx = (s.vx / speed) * 3;
            dy = (s.vy / speed) * 3;
          }
        }
        const tx = s.x - dx;
        const ty = s.y - dy;

        // Outer glow trail
        ctx!.globalAlpha = alpha * 0.2;
        ctx!.strokeStyle = `rgba(255, 120, 30, 1)`;
        ctx!.lineWidth = s.size * 4;
        ctx!.beginPath();
        ctx!.moveTo(tx, ty);
        ctx!.lineTo(s.x, s.y);
        ctx!.stroke();

        // Core trail â€” white-hot to orange based on brightness
        const r = 255;
        const g = Math.round(180 + s.brightness * 70);
        const b = Math.round(80 + s.brightness * 150);
        ctx!.globalAlpha = alpha * 0.85;
        ctx!.strokeStyle = `rgb(${r}, ${g}, ${b})`;
        ctx!.lineWidth = s.size;
        ctx!.beginPath();
        ctx!.moveTo(tx, ty);
        ctx!.lineTo(s.x, s.y);
        ctx!.stroke();

        // Hot point at the head
        ctx!.globalAlpha = alpha;
        ctx!.fillStyle = `rgba(255, 255, 220, 1)`;
        ctx!.beginPath();
        ctx!.arc(s.x, s.y, s.size * 0.6, 0, Math.PI * 2);
        ctx!.fill();
      }

      ctx!.globalAlpha = 1;

      // --- Tilt ---
      if (mouseInHero) {
        const heroRect = hero!.getBoundingClientRect();
        const hCX = heroRect.left + heroRect.width / 2;
        const hCY = heroRect.top + heroRect.height / 2;
        const targetTiltX = ((mouseY - hCY) / (heroRect.height / 2)) * -3;
        const targetTiltY = ((mouseX - hCX) / (heroRect.width / 2)) * 3;
        tiltX = lerp(tiltX, targetTiltX, 0.1);
        tiltY = lerp(tiltY, targetTiltY, 0.1);
      } else {
        tiltX = lerp(tiltX, 0, 0.05);
        tiltY = lerp(tiltY, 0, 0.05);
      }

      if (Math.abs(tiltX) > 0.02 || Math.abs(tiltY) > 0.02) {
        touchmarkEl!.style.transform =
          `perspective(600px) rotateX(${tiltX.toFixed(2)}deg) rotateY(${tiltY.toFixed(2)}deg)`;
      } else {
        touchmarkEl!.style.transform = '';
      }
    }

    tick();
  }

  // astro:page-load fires on initial load AND after every view transition
  document.addEventListener('astro:page-load', init);
</script>
